/*
  LCD
    @omzn  2020/10/20
*/

#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include "inc/hw_i2c.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_qei.h"
#include "inc/hw_timer.h"
#include "driverlib/rom.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/pwm.h"
#include "driverlib/timer.h"

#include "driverlib/qei.h"
#include "utils/uartstdio.h"
#include "utils/uartstdio.c" //strong-arm method

#include "periphConf.h" //generated by PinMux

#include "my_util.h"
#include "my_i2c.h"

#include "buzzer.h"
#include "lcd_SB1602.h"

//*****************************************************************************
// Global variables
//*****************************************************************************
uint8_t face1[] = {SB1602_DATA_BURST, '(', 0xF3, 0xA5, 'w', 0xA5, 0xF4, ')'};
uint8_t face2[] = {SB1602_DATA_BURST, '(', 0xF4, 0xA5, 'w', 0xA5, 0xF3, ')'};
uint8_t msg1[] = {SB1602_DATA_BURST, 0xBC, 0xAC, 0xB7, 0xB0, 0xDD, '!'};
uint8_t msg2[] = {SB1602_DATA_BURST, 0xBC, 0xAE, 0xCE, 0xDE, '-', 0xDD};

uint32_t count = 0;

uint32_t button_counter = 0;
bool stop = true;

//*****************************************************************************
//
// This function sets up UART0 to be used for a console to display information
// as the example is running.
//
//*****************************************************************************
void initConsole(void) {
    // Enable GPIO port A which is used for UART0 pins.
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    // Configure the pin muxing for UART0 functions on port A0 and A1.
    // This step is not necessary if your part does not support pin muxing.
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    // Enable UART0 so that we can configure the clock.
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
    // Use the internal 16MHz oscillator as the UART clock source.
    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
    // Select the alternate (UART) function for these pins.
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
    // Initialize the UART for console I/O.
    UARTStdioConfig(0, 9600, 16000000);
}

void initInterruptPins(void) {
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    GPIODirModeSet(GPIO_PORTF_BASE, INT_LEFT_BUTTON, GPIO_DIR_MODE_IN);
    GPIOPadConfigSet(GPIO_PORTF_BASE, INT_LEFT_BUTTON,
                     GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
    GPIOIntClear(GPIO_PORTF_BASE, INT_LEFT_BUTTON);

    GPIOIntRegister(GPIO_PORTF_BASE, SW1PinIntHandler);
    GPIOIntTypeSet(GPIO_PORTF_BASE, INT_LEFT_BUTTON,
                   GPIO_FALLING_EDGE);
    GPIOIntEnable(GPIO_PORTF_BASE, INT_LEFT_BUTTON);
}

//*****************************************************************************
// Event handers
//*****************************************************************************

uint32_t power(uint32_t a, uint8_t b) {
    int r = 1;
    for (int i = 0; i < b; ++i) {
        r *= a;
    }
    return r;
}

void SysTickIntHandler(void) {
    static uint32_t led_color = LED_ALL;
    static uint32_t tick_count = 0;
    static uint8_t x = 4;
    static uint32_t buff = 0;
    static uint8_t buff_8 = 0;

    if (!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4)) {
        button_counter++;
        if (button_counter >= 100) {
            button_counter = 0;
            count = 0;
            clearLCD();
            delay_ms(5);
            uint8_t buff[] = {'0', '0', ':', '0', '0', ':', '0', '0'};
            setAddressLCD(4, 1);
            writeTextLCD(buff, 8);
        }
    } else {
        button_counter = 0;
    }

    if (tick_count % 50 == 0) {
        led_color = ~led_color;
        GPIOPinWrite(GPIO_PORTF_BASE, LED_GREEN, led_color);
        if (tick_count % 32 == 0) {
            tick_count = 0;
        }
    }

//    if (!stop) {
//        count++;
//        int p;
//
//        for (int i = 0; i < 3; ++i) {
//            p = power(60, 2 - i);
//            buff = count / p;
//            if (buff == 0) {
//                setAddressLCD(4 + i * 3, 1);
//                uint8_t buff_c[] = {'0', '0'};
//                writeTextLCD(buff_c, 2);
//                continue;
//            }
//            if (buff >= 60) {
//                buff = buff % 60;
//            }
//            setAddressLCD(4 + i * 3, 1);
//            uint8_t buff_c[] = {buff / 10 + 48, buff % 10 + 48};
//            writeTextLCD(buff_c, 2);
//        }
//    }
    tick_count++;
}

void SW1PinIntHandler(void) {
    GPIOIntDisable(GPIO_PORTF_BASE, INT_LEFT_BUTTON);
    GPIOIntClear(GPIO_PORTF_BASE, INT_LEFT_BUTTON);

    stop = !stop;

    showIcon(0x00,0x10);

    UARTprintf("SW1 pushed\n");
    GPIOIntEnable(GPIO_PORTF_BASE, INT_LEFT_BUTTON);
}

int main(void) {
    // Set the clocking to run directly from the crystal.
    ROM_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
                       SYSCTL_XTAL_16MHZ);
    // Set up ports hardware (see periphConf.c)
    PortFunctionInit();

    // Set up interrupts (you can specify GPIO interrupt initialization here)
    initInterruptPins();

    // Initialize console
    initConsole();
    UARTprintf("LCD example\n");

    // Initialize buzzer
    initBuzzer();

    // Initialize two I2C Masters
    initI2C(I2C3_BASE);
    // Initialize LCD module
    initLCD();

    SysTickPeriodSet(SysCtlClockGet() / 100);
    SysTickEnable();
    SysTickIntRegister(SysTickIntHandler);
    SysTickIntEnable();

    clearLCD();
    delay_ms(5);
    uint8_t buff[] = {'0', '0', ':', '0', '0', ':', '0', '0'};
    setAddressLCD(4, 1);
    writeTextLCD(buff, 8);

    while (1);
}

